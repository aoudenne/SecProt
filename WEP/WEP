(* WEP Protocol in ProVerif typed Horn Logic
   by Jerremy Adams and Ashley Oudenne
   
   
   Protocol Descriptions:
   A -> B : v, (P XOR RC4(v, kAB)
   
   where P = <m, checksum(m)>
   
   
 *)

pred c(any_type) [decompData, elimVar].

type symKey. (* symmetric keys used for encryption between source and destination *)
type principal. (* participants in message exchange *)
type initVector. (* initialization vectors for rc4 *)
type invariant. (* security invariants we verify *)

fun rc4(initVector, symKey):bitstring. (* given an initialization vector and a key, generate a keystream *)
fun checkSum(bitstring):bitstring. (* Checksum algorithm for determining message integrity *)
fun xor(bitstring, bitstring):bitstring. (* Function to represent the computation of exclusive or. *)

name A:principal. (* Source of wireless communication *)
name B:principal. (* Destination for wireless communication *)
name Kab:symKey.  (* Key shared between A and B *)
name v:initVector. (* The initialization vector used for this session *)
name m:bitstring.  (* The message packet sent *)
name secret:invariant. (* Confidentiality assumption.  If generated, there is a confientiality attack on this protocol *)

query c(secret[]). (* Attempt to generate a confidentiality break *)

clauses

(* Universal knowledge for all participants (both legitimate and illegitimate: *)

(* XOR capabilities *)
forall x:bitstring, y:bitstring; c(xor(x,y)) -> c(xor(y,x)); (* commutativity *)
forall x:bitstring, y:bitstring; c(xor(x,y)) & c(x) -> c(y); (* inverting an XOR *)
forall x:bitstring, y:bitstring; c(xor(x,y)) & c(y) -> c(x); 
forall x:bitstring, y:bitstring; c(x) & c(y) -> c(xor(x,y)); (* Constructing an XOR *)
forall x:bitstring, y:bitstring, z:bitstring; c(xor(xor(x,y),xor(z,y))) -> c(xor(x,z)); (* Distributivity of XOR *)
(* Checksum capabilities *)
forall x:bitstring; c(x) -> c(checkSum(x)); (* Generate a checksum for any known message *)

(* Decompose two part message *)
forall x:bitstring,y:bitstring; c((x,y)) -> c(x); 
forall x:bitstring, y:bitstring; c((x,y)) -> c(y);

(* Create two part message *)
forall x:bitstring, y:bitstring; c(x) & c(y) -> c((x,y));

(* A -> B *)
forall p:principal; c(v[]);  (* put IV on the channel in the clear *)
forall p:principal; c( xor ((m[p], checkSum(m[p])), rc4(v[], Kab[]))); (* send message by XORing the message with the keystream generated by RC4 *)

(*Invariant*)
(* if we can generate a clear-text message or the XOR of two distinct plain texts, we have a security breach. *)
forall p:principal ; c(m[p]) -> c(secret[]);
forall p:principal, q:principal; c(xor((m[p],checkSum(m[p])),(m[q],checkSum(m[q])))) & p <> q -> c(secret[]). 

